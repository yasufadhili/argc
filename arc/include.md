# Handling Include Files in a C++ Flex/Bison Parser

To gracefully handle include files in a C++ Flex/Bison parser while enforcing the one-module-per-file rule and preventing circular includes, you'll need a systematic approach that coordinates between the lexer and parser. Here's a detailed solution:

## 1. Data Structures for File Tracking

First, you'll need structures to track file inclusion:

```cpp
struct FileInfo {
    std::string filename;
    int line_number = 1;
    YY_BUFFER_STATE buffer = nullptr;
    FILE* file = nullptr;
};

// Stack to keep track of included files
std::stack<FileInfo> file_stack;

// Set to detect circular includes
std::unordered_set<std::string> currently_processed_files;

// Track if module declaration has been seen in current file
bool module_declared = false;
```

## 2. Lexer Modifications (Flex)

Add support in your Flex file for handling includes and tracking line numbers:

```cpp
%{
#include <string>
#include <stack>
#include <unordered_set>
#include <filesystem>
#include "parser.hpp" // Generated by Bison

// Forward declarations
void process_include(const std::string& filename);
void report_error(const std::string& msg);
%}

%option noyywrap
%option yylineno

%x INCLUDE

%%

^[ \t]*"module"[ \t]+[a-zA-Z][a-zA-Z0-9_]*[ \t]*";" {
    if (!file_stack.empty() && file_stack.top().line_number > 1) {
        report_error("Module declaration must be the first statement in the file");
        // Return the token anyway to allow parser to continue with error recovery
    } else if (module_declared) {
        report_error("Multiple module declarations in file");
    } else {
        module_declared = true;
    }
    return MODULE_DECL; // Define this token in your parser
}

^[ \t]*"include"[ \t]+\"  { BEGIN(INCLUDE); } // Start include state

<INCLUDE>[^\"\n]+\"[ \t]*";" {
    std::string filename = yytext;
    // Remove quotes and semicolon from the filename
    filename = filename.substr(0, filename.find('"', 0));
    process_include(filename);
    BEGIN(INITIAL);
}

\n      { if (!file_stack.empty()) file_stack.top().line_number++; }
.       { /* Other rules for your language */ }

%%

void process_include(const std::string& filename) {
    // Convert to absolute path to handle relative includes properly
    std::filesystem::path abs_path = std::filesystem::absolute(filename);
    std::string abs_filename = abs_path.string();
    
    // Check for circular includes
    if (currently_processed_files.find(abs_filename) != currently_processed_files.end()) {
        report_error("Circular include detected: " + filename);
        return;
    }
    
    FILE* new_file = fopen(abs_filename.c_str(), "r");
    if (!new_file) {
        report_error("Could not open include file: " + filename);
        return;
    }
    
    // Save current file state
    if (!file_stack.empty()) {
        file_stack.top().buffer = YY_CURRENT_BUFFER;
    }
    
    // Set up for new file
    FileInfo new_info;
    new_info.filename = abs_filename;
    new_info.file = new_file;
    new_info.line_number = 1;
    file_stack.push(new_info);
    
    // Track this file to detect circular includes
    currently_processed_files.insert(abs_filename);
    
    // Reset module declaration flag for new file
    module_declared = false;
    
    // Switch lexer to the new file
    yy_switch_to_buffer(yy_create_buffer(new_file, YY_BUF_SIZE));
}

// Called when EOF is reached to handle file stack
int yywrap() {
    if (file_stack.empty()) {
        return 1; // No more input
    }
    
    // Close current file
    FileInfo current = file_stack.top();
    fclose(current.file);
    yy_delete_buffer(YY_CURRENT_BUFFER);
    file_stack.pop();
    
    // Remove from the processed files set when we're done with it
    currently_processed_files.erase(current.filename);
    
    if (file_stack.empty()) {
        return 1; // No more input
    } else {
        // Return to the previous file
        yy_switch_to_buffer(file_stack.top().buffer);
        return 0; // Continue processing
    }
}

void yyerror(const char* msg) {
    std::string file_info = file_stack.empty() ? 
        "unknown" : file_stack.top().filename + ":" + 
        std::to_string(file_stack.top().line_number);
    
    std::cerr << file_info << ": " << msg << std::endl;
}

void report_error(const std::string& msg) {
    std::string file_info = file_stack.empty() ? 
        "unknown" : file_stack.top().filename + ":" + 
        std::to_string(file_stack.top().line_number);
    
    std::cerr << file_info << ": " << msg << std::endl;
}
```

## 3. Parser Modifications (Bison)

Update your Bison grammar to support module declarations and includes:

```cpp
%{
#include <iostream>
#include <string>
#include <stack>
#include <unordered_set>

// Forward declarations
extern int yylex();
void yyerror(const char* msg);
extern std::stack<FileInfo> file_stack;
extern bool module_declared;
%}

%token MODULE_DECL
%token INCLUDE
// Other tokens...

%%

program : statements
        ;

statements : statement
          | statements statement
          ;

statement : module_declaration
          | include_statement
          | other_statement
          ;

module_declaration : MODULE_DECL
                   ;

include_statement : INCLUDE
                  ;

// Other grammar rules...

%%

// Main function
int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " input_file\n";
        return 1;
    }
    
    FILE* input = fopen(argv[1], "r");
    if (!input) {
        std::cerr << "Could not open input file: " << argv[1] << "\n";
        return 1;
    }
    
    // Initialize with root file
    FileInfo root;
    root.filename = argv[1];
    root.file = input;
    file_stack.push(root);
    currently_processed_files.insert(std::filesystem::absolute(argv[1]).string());
    
    // Set up lexer with initial file
    yy_switch_to_buffer(yy_create_buffer(input, YY_BUF_SIZE));
    
    // Start parsing
    return yyparse();
}
```

## 4. Error Handling and Line Number Tracking

The implementation above:
- Tracks line numbers to give accurate error locations
- Reports detailed errors with file and line information
- Properly handles include file processing and returns to parent files
- Enforces the one-module-per-file rule by checking if declarations appear early

## 5. File Opening and Path Resolution

The solution uses `std::filesystem` to convert relative paths to absolute paths, which helps:
- Properly resolve included files regardless of the current working directory
- Detect circular includes even when the same file is referenced through different relative paths

## 6. Circular Include Detection

The system prevents circular includes by:
1. Tracking all currently processed files in a set using absolute paths
2. Checking this set before processing a new include
3. Reporting an error if an include would create a cycle
4. Removing files from the set when we finish processing them

## Implementation Notes

1. This implementation assumes a complete restart of the lexer when processing includes. When you return from an included file, it picks up where it left off in the parent file.

2. The module declaration check is enforced by:
   - Checking the line number when a module declaration is encountered
   - Ensuring there's only one module declaration per file
   - Warning if the module is not the first statement

3. The synchronization between lexer and parser is maintained by:
   - Properly managing buffer states
   - Using a file stack to track context
   - Ensuring the lexer state is preserved when switching between files

